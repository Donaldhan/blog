netty 事件执行器组和事件执行器定义及抽象实现：[url]http://donald-draper.iteye.com/blog/2391257[/url]
引言:
前面一篇文章我们看了事件执行器组和事件执行器的接口定义，先来回顾一下：
    事件循环组EventLoopGroup为一个特殊的事件执行器组EventExecutorGroup，可以注册通道，以便在事件循环中，被后面的选择操作处理器。事件执行器组继承了JUC的调度执行器服务ScheduledExecutorService，用迭代器Iterable<EventExecutor>管理组内的事件执行器。事件执行器是一个特殊的事件执行器组。Nio多线程事件循环NioEventLoopGroup可以理解为多线程版MultithreadEventExecutorGroup的事件执行器组。
    事件执行器组EventExecutorGroup主要提供了关闭事件执行器组管理的执行器的相关方法，获取事件执行器组管理的事件执行器和执行任务线程方法。
    事件执行器EventExecutor为一个特殊的事件执行器组EventExecutorGroup，提供了获取事件执行器组的下一个事件执行器方法，判断线程是否在当前事件循环中以及创建可写的异步任务结果和进度结果，及已经成功失败的异步结果。
    抽象事件执行器组AbstractEventExecutorGroup，所有与调度执行器关联的提交任务和调度任务方法，直接委托给事件执行器组的下一个事件执行器相应方法执行。graceful方式关闭事件执行器组，默认关闭间隔为2s，超时时间为25s，具体定义在抽象事件执行器AbstractEventExecutor中。
    抽象事件执行器，继承了抽象执行器服务AbstractExecutorService，提交任务线程，直接委托给父类抽象执行器服务，不支持延时调度的周期间歇性调度任务线程，多个一个安全地执行给定任务线程方法，捕捉执行过程中抛出的异常。由于抽象的事件执行器是一个特殊的事件执行器组，内部事件执行器selfCollection（Collections.<EventExecutor>singleton(this)），是自己单例集，next方法返回的是自己。


我们先把Nio事件循环继承树结构列一下：
事件循环组EventLoopGroup和事件执行器组EventExecutorGroup及事件执行器EventExecutor的关系；
[code="java"]/**
 * {@link MultithreadEventLoopGroup} implementations which is used for NIO {@link Selector} based {@link Channel}s.
 Nio事件循环组NioEventLoopGroup为多线程事件循环组的事件，主要用于基于通道的Nio选择器相关操作。
 */
public class NioEventLoopGroup extends MultithreadEventLoopGroup {
[/code]
[code="java"]/**
 * Abstract base class for {@link EventLoopGroup} implementations that handles their tasks with multiple threads at
 * the same time.
 多线程事件循环组MultithreadEventLoopGroup为事件循环组的实现，可以在同一时间多线程处理任务。
 */
public abstract class MultithreadEventLoopGroup extends MultithreadEventExecutorGroup implements EventLoopGroup {[/code]

[code="java"]/**
 * Abstract base class for {@link EventExecutorGroup} implementations that handles their tasks with multiple threads at
 * the same time.
 多线程事件执行器组MultithreadEventExecutorGroup可以在同一时间多线程处理任务。
 */
public abstract class MultithreadEventExecutorGroup extends AbstractEventExecutorGroup {[/code]

[code="java"]/**
 * Abstract base class for {@link EventExecutorGroup} implementations.
 事件循环中的抽象实现
 */
public abstract class AbstractEventExecutorGroup implements EventExecutorGroup {[/code]
[code="java"]
/**
 * The {@link EventExecutorGroup} is responsible for providing the {@link EventExecutor}'s to use
 * via its {@link #next()} method. Besides this, it is also responsible for handling their
 * life-cycle and allows shutting them down in a global fashion.
 事件执行器组通道next方法提供事件执行器。除此之外，负责他们的生命循环，并允许以全局的方式关闭
 *
 */
public interface EventExecutorGroup extends ScheduledExecutorService, Iterable<EventExecutor> {[/code]
调度执行器ScheduledExecutorService为JUC包中的执行器服务，用迭代器Iterable<EventExecutor>管理组内的
事件执行器。



[code="java"]/**
 * The {@link EventExecutor} is a special {@link EventExecutorGroup} which comes
 * with some handy methods to see if a {@link Thread} is executed in a event loop.
 * Besides this, it also extends the {@link EventExecutorGroup} to allow for a generic
 * way to access methods.
事件执行器EventExecutor是一个特殊的事件执行器组，如果线程在事件循环中执行，事件执行器可以处理
相关的操作。除此之外，拓展了事件执行器组的相关方法，可以用一般的方式访问事件执行器组的相关方法。
 *
 */
public interface EventExecutor extends EventExecutorGroup {[/code]

再来看事件循环组的另一个分支EventLoopGroup

[code="java"]/**
 * Special {@link EventExecutorGroup} which allows registering {@link Channel}s that get
 * processed for later selection during the event loop.
 事件循环组为一个特殊的事件执行器组，可以注册通道，以便在事件循环中，被后面的选择操作处理器。
 *
 */
public interface EventLoopGroup extends EventExecutorGroup {[/code]

今天我们来看一下多线程事件执行器组：
/**
 * Abstract base class for {@link EventExecutorGroup} implementations that handles their tasks with multiple threads at
 * the same time.
 多线程事件执行器组MultithreadEventExecutorGroup可以在同一时间多线程处理任务。
 */
public abstract class MultithreadEventExecutorGroup extends AbstractEventExecutorGroup {



