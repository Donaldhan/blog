



 @Override
 public final void bind(final SocketAddress localAddress, final ChannelPromise promise) {
     assertEventLoop();

     if (!promise.setUncancellable() || !ensureOpen(promise)) {
         return;
     }

     // See: https://github.com/netty/netty/issues/576
     if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &&
         localAddress instanceof InetSocketAddress &&
         !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &&
         !PlatformDependent.isWindows() && !PlatformDependent.maybeSuperUser()) {
         // Warn a user about the fact that a non-root user can't receive a
         // broadcast packet on *nix if the socket is bound on non-wildcard address.
         logger.warn(
                 "A non-root user can't receive a broadcast packet if the socket " +
                 "is not bound to a wildcard address; binding to a non-wildcard " +
                 "address (" + localAddress + ") anyway as requested.");
     }

     boolean wasActive = isActive();
     try {
         doBind(localAddress);
     } catch (Throwable t) {
         safeSetFailure(promise, t);
         closeIfClosed();
         return;
     }

     if (!wasActive && isActive()) {
         invokeLater(new Runnable() {
             @Override
             public void run() {
                 pipeline.fireChannelActive();
             }
         });
     }

     safeSetSuccess(promise);
 }

 @Override
 public final void disconnect(final ChannelPromise promise) {
     assertEventLoop();

     if (!promise.setUncancellable()) {
         return;
     }

     boolean wasActive = isActive();
     try {
         doDisconnect();
     } catch (Throwable t) {
         safeSetFailure(promise, t);
         closeIfClosed();
         return;
     }

     if (wasActive && !isActive()) {
         invokeLater(new Runnable() {
             @Override
             public void run() {
                 pipeline.fireChannelInactive();
             }
         });
     }

     safeSetSuccess(promise);
     closeIfClosed(); // doDisconnect() might have closed the channel
 }

 @Override
 public final void close(final ChannelPromise promise) {
     assertEventLoop();

     close(promise, CLOSE_CLOSED_CHANNEL_EXCEPTION, CLOSE_CLOSED_CHANNEL_EXCEPTION, false);
 }

 private void close(final ChannelPromise promise, final Throwable cause,
                    final ClosedChannelException closeCause, final boolean notify) {
     if (!promise.setUncancellable()) {
         return;
     }

     final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
     if (outboundBuffer == null) {
         // Only needed if no VoidChannelPromise.
         if (!(promise instanceof VoidChannelPromise)) {
             // This means close() was called before so we just register a listener and return
             closeFuture.addListener(new ChannelFutureListener() {
                 @Override
                 public void operationComplete(ChannelFuture future) throws Exception {
                     promise.setSuccess();
                 }
             });
         }
         return;
     }

     if (closeFuture.isDone()) {
         // Closed already.
         safeSetSuccess(promise);
         return;
     }

     final boolean wasActive = isActive();
     this.outboundBuffer = null; // Disallow adding any messages and flushes to outboundBuffer.
     Executor closeExecutor = prepareToClose();
     if (closeExecutor != null) {
         closeExecutor.execute(new Runnable() {
             @Override
             public void run() {
                 try {
                     // Execute the close.
                     doClose0(promise);
                 } finally {
                     // Call invokeLater so closeAndDeregister is executed in the EventLoop again!
                     invokeLater(new Runnable() {
                         @Override
                         public void run() {
                             // Fail all the queued messages
                             outboundBuffer.failFlushed(cause, notify);
                             outboundBuffer.close(closeCause);
                             fireChannelInactiveAndDeregister(wasActive);
                         }
                     });
                 }
             }
         });
     } else {
         try {
             // Close the channel and fail the queued messages in all cases.
             doClose0(promise);
         } finally {
             // Fail all the queued messages.
             outboundBuffer.failFlushed(cause, notify);
             outboundBuffer.close(closeCause);
         }
         if (inFlush0) {
             invokeLater(new Runnable() {
                 @Override
                 public void run() {
                     fireChannelInactiveAndDeregister(wasActive);
                 }
             });
         } else {
             fireChannelInactiveAndDeregister(wasActive);
         }
     }
 }

 private void doClose0(ChannelPromise promise) {
     try {
         doClose();
         closeFuture.setClosed();
         safeSetSuccess(promise);
     } catch (Throwable t) {
         closeFuture.setClosed();
         safeSetFailure(promise, t);
     }
 }

 private void fireChannelInactiveAndDeregister(final boolean wasActive) {
     deregister(voidPromise(), wasActive && !isActive());
 }

 @Override
 public final void closeForcibly() {
     assertEventLoop();

     try {
         doClose();
     } catch (Exception e) {
         logger.warn("Failed to close a channel.", e);
     }
 }

 @Override
 public final void deregister(final ChannelPromise promise) {
     assertEventLoop();

     deregister(promise, false);
 }

 private void deregister(final ChannelPromise promise, final boolean fireChannelInactive) {
     if (!promise.setUncancellable()) {
         return;
     }

     if (!registered) {
         safeSetSuccess(promise);
         return;
     }

     // As a user may call deregister() from within any method while doing processing in the ChannelPipeline,
     // we need to ensure we do the actual deregister operation later. This is needed as for example,
     // we may be in the ByteToMessageDecoder.callDecode(...) method and so still try to do processing in
     // the old EventLoop while the user already registered the Channel to a new EventLoop. Without delay,
     // the deregister operation this could lead to have a handler invoked by different EventLoop and so
     // threads.
     //
     // See:
     // https://github.com/netty/netty/issues/4435
     invokeLater(new Runnable() {
         @Override
         public void run() {
             try {
                 doDeregister();
             } catch (Throwable t) {
                 logger.warn("Unexpected exception occurred while deregistering a channel.", t);
             } finally {
                 if (fireChannelInactive) {
                     pipeline.fireChannelInactive();
                 }
                 // Some transports like local and AIO does not allow the deregistration of
                 // an open channel.  Their doDeregister() calls close(). Consequently,
                 // close() calls deregister() again - no need to fire channelUnregistered, so check
                 // if it was registered.
                 if (registered) {
                     registered = false;
                     pipeline.fireChannelUnregistered();
                 }
                 safeSetSuccess(promise);
             }
         }
     });
 }

 @Override
 public final void beginRead() {
     assertEventLoop();

     if (!isActive()) {
         return;
     }

     try {
         doBeginRead();
     } catch (final Exception e) {
         invokeLater(new Runnable() {
             @Override
             public void run() {
                 pipeline.fireExceptionCaught(e);
             }
         });
         close(voidPromise());
     }
 }

 @Override
 public final void write(Object msg, ChannelPromise promise) {
     assertEventLoop();

     ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
     if (outboundBuffer == null) {
         // If the outboundBuffer is null we know the channel was closed and so
         // need to fail the future right away. If it is not null the handling of the rest
         // will be done in flush0()
         // See https://github.com/netty/netty/issues/2362
         safeSetFailure(promise, WRITE_CLOSED_CHANNEL_EXCEPTION);
         // release message now to prevent resource-leak
         ReferenceCountUtil.release(msg);
         return;
     }

     int size;
     try {
         msg = filterOutboundMessage(msg);
         size = pipeline.estimatorHandle().size(msg);
         if (size < 0) {
             size = 0;
         }
     } catch (Throwable t) {
         safeSetFailure(promise, t);
         ReferenceCountUtil.release(msg);
         return;
     }

     outboundBuffer.addMessage(msg, size, promise);
 }

 @Override
 public final void flush() {
     assertEventLoop();

     ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
     if (outboundBuffer == null) {
         return;
     }

     outboundBuffer.addFlush();
     flush0();
 }

 @SuppressWarnings("deprecation")
 protected void flush0() {
     if (inFlush0) {
         // Avoid re-entrance
         return;
     }

     final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
     if (outboundBuffer == null || outboundBuffer.isEmpty()) {
         return;
     }

     inFlush0 = true;

     // Mark all pending write requests as failure if the channel is inactive.
     if (!isActive()) {
         try {
             if (isOpen()) {
                 outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, true);
             } else {
                 // Do not trigger channelWritabilityChanged because the channel is closed already.
                 outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);
             }
         } finally {
             inFlush0 = false;
         }
         return;
     }

     try {
         doWrite(outboundBuffer);
     } catch (Throwable t) {
         if (t instanceof IOException && config().isAutoClose()) {
             /**
              * Just call {@link #close(ChannelPromise, Throwable, boolean)} here which will take care of
              * failing all flushed messages and also ensure the actual close of the underlying transport
              * will happen before the promises are notified.
              *
              * This is needed as otherwise {@link #isActive()} , {@link #isOpen()} and {@link #isWritable()}
              * may still return {@code true} even if the channel should be closed as result of the exception.
              */
             close(voidPromise(), t, FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);
         } else {
             outboundBuffer.failFlushed(t, true);
         }
     } finally {
         inFlush0 = false;
     }
 }

 @Override
 public final ChannelPromise voidPromise() {
     assertEventLoop();

     return unsafeVoidPromise;
 }

 @Deprecated
 protected final boolean ensureOpen(ChannelPromise promise) {
     if (isOpen()) {
         return true;
     }

     safeSetFailure(promise, ENSURE_OPEN_CLOSED_CHANNEL_EXCEPTION);
     return false;
 }

 /**
  * Marks the specified {@code promise} as success.  If the {@code promise} is done already, log a message.
  */
 protected final void safeSetSuccess(ChannelPromise promise) {
     if (!(promise instanceof VoidChannelPromise) && !promise.trySuccess()) {
         logger.warn("Failed to mark a promise as success because it is done already: {}", promise);
     }
 }

 /**
  * Marks the specified {@code promise} as failure.  If the {@code promise} is done already, log a message.
  */
 protected final void safeSetFailure(ChannelPromise promise, Throwable cause) {
     if (!(promise instanceof VoidChannelPromise) && !promise.tryFailure(cause)) {
         logger.warn("Failed to mark a promise as failure because it's done already: {}", promise, cause);
     }
 }

 protected final void closeIfClosed() {
     if (isOpen()) {
         return;
     }
     close(voidPromise());
 }

 private void invokeLater(Runnable task) {
     try {
         // This method is used by outbound operation implementations to trigger an inbound event later.
         // They do not trigger an inbound event immediately because an outbound operation might have been
         // triggered by another inbound event handler method.  If fired immediately, the call stack
         // will look like this for example:
         //
         //   handlerA.inboundBufferUpdated() - (1) an inbound handler method closes a connection.
         //   -> handlerA.ctx.close()
         //      -> channel.unsafe.close()
         //         -> handlerA.channelInactive() - (2) another inbound handler method called while in (1) yet
         //
         // which means the execution of two inbound handler methods of the same handler overlap undesirably.
         eventLoop().execute(task);
     } catch (RejectedExecutionException e) {
         logger.warn("Can't invoke task later as EventLoop rejected it", e);
     }
 }

 /**
  * Appends the remote address to the message of the exceptions caused by connection attempt failure.
  */
 protected final Throwable annotateConnectException(Throwable cause, SocketAddress remoteAddress) {
     if (cause instanceof ConnectException) {
         return new AnnotatedConnectException((ConnectException) cause, remoteAddress);
     }
     if (cause instanceof NoRouteToHostException) {
         return new AnnotatedNoRouteToHostException((NoRouteToHostException) cause, remoteAddress);
     }
     if (cause instanceof SocketException) {
         return new AnnotatedSocketException((SocketException) cause, remoteAddress);
     }

     return cause;
 }

 /**
  * Prepares to close the {@link Channel}. If this method returns an {@link Executor}, the
  * caller must call the {@link Executor#execute(Runnable)} method with a task that calls
  * {@link #doClose()} on the returned {@link Executor}. If this method returns {@code null},
  * {@link #doClose()} must be called from the caller thread. (i.e. {@link EventLoop})
  */
 protected Executor prepareToClose() {
     return null;
 }