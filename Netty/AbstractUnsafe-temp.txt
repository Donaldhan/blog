



 

 @Override
 public final void disconnect(final ChannelPromise promise) {
     assertEventLoop();

     if (!promise.setUncancellable()) {
         return;
     }

     boolean wasActive = isActive();
     try {
         doDisconnect();
     } catch (Throwable t) {
         safeSetFailure(promise, t);
         closeIfClosed();
         return;
     }

     if (wasActive && !isActive()) {
         invokeLater(new Runnable() {
             @Override
             public void run() {
                 pipeline.fireChannelInactive();
             }
         });
     }

     safeSetSuccess(promise);
     closeIfClosed(); // doDisconnect() might have closed the channel
 }



 @Override
 public final void deregister(final ChannelPromise promise) {
     assertEventLoop();

     deregister(promise, false);
 }


 @Override
 public final void write(Object msg, ChannelPromise promise) {
     assertEventLoop();

     ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
     if (outboundBuffer == null) {
         // If the outboundBuffer is null we know the channel was closed and so
         // need to fail the future right away. If it is not null the handling of the rest
         // will be done in flush0()
         // See https://github.com/netty/netty/issues/2362
         safeSetFailure(promise, WRITE_CLOSED_CHANNEL_EXCEPTION);
         // release message now to prevent resource-leak
         ReferenceCountUtil.release(msg);
         return;
     }

     int size;
     try {
         msg = filterOutboundMessage(msg);
         size = pipeline.estimatorHandle().size(msg);
         if (size < 0) {
             size = 0;
         }
     } catch (Throwable t) {
         safeSetFailure(promise, t);
         ReferenceCountUtil.release(msg);
         return;
     }

     outboundBuffer.addMessage(msg, size, promise);
 }

 @Override
 public final void flush() {
     assertEventLoop();

     ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
     if (outboundBuffer == null) {
         return;
     }

     outboundBuffer.addFlush();
     flush0();
 }

 @SuppressWarnings("deprecation")
 protected void flush0() {
     if (inFlush0) {
         // Avoid re-entrance
         return;
     }

     final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
     if (outboundBuffer == null || outboundBuffer.isEmpty()) {
         return;
     }

     inFlush0 = true;

     // Mark all pending write requests as failure if the channel is inactive.
     if (!isActive()) {
         try {
             if (isOpen()) {
                 outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, true);
             } else {
                 // Do not trigger channelWritabilityChanged because the channel is closed already.
                 outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);
             }
         } finally {
             inFlush0 = false;
         }
         return;
     }

     try {
         doWrite(outboundBuffer);
     } catch (Throwable t) {
         if (t instanceof IOException && config().isAutoClose()) {
             /**
              * Just call {@link #close(ChannelPromise, Throwable, boolean)} here which will take care of
              * failing all flushed messages and also ensure the actual close of the underlying transport
              * will happen before the promises are notified.
              *
              * This is needed as otherwise {@link #isActive()} , {@link #isOpen()} and {@link #isWritable()}
              * may still return {@code true} even if the channel should be closed as result of the exception.
              */
             close(voidPromise(), t, FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);
         } else {
             outboundBuffer.failFlushed(t, true);
         }
     } finally {
         inFlush0 = false;
     }
 }

 @Override
 public final ChannelPromise voidPromise() {
     assertEventLoop();

     return unsafeVoidPromise;
 }


 /**
  * Appends the remote address to the message of the exceptions caused by connection attempt failure.
  */
 protected final Throwable annotateConnectException(Throwable cause, SocketAddress remoteAddress) {
     if (cause instanceof ConnectException) {
         return new AnnotatedConnectException((ConnectException) cause, remoteAddress);
     }
     if (cause instanceof NoRouteToHostException) {
         return new AnnotatedNoRouteToHostException((NoRouteToHostException) cause, remoteAddress);
     }
     if (cause instanceof SocketException) {
         return new AnnotatedSocketException((SocketException) cause, remoteAddress);
     }

     return cause;
 }
